package FileTransmi;

import java.io.*;
import java.net.*;

import android.os.*;

public class FileTransmi extends Thread{
	String uri,idx;
	int serverResponseCode = 0;
	public FileTransmi(String uri,String idx,Handler handler) {
		// TODO Auto-generated constructor stub
		this.uri = uri;
		
		this.idx = idx;
	}
	@Override
	public void run() {
		// TODO Auto-generated method stub
		super.run();
		upLoadFile(uri);
	}
	public int upLoadFile(String sourceFileUri ){
		String photo_path = sourceFileUri.substring(28,sourceFileUri.length())
		String fileName = photo_path;
		HttpURLConnection conn = null;
		String lineEnd = "\r\n";
		String twoHyphens = "--";
		DataOutputStream dos = null;
		String boundary = "*****";
		String delimiter = lineEnd + twoHyphens + boundary + lineEnd;
		StringBuffer postDataBuilder = new StringBuffer();
		postDataBuilder.append(delimiter);
		postDataBuilder.append(setValue("idx", idx));
		postDataBuilder.append(delimiter);
		postDataBuilder.append(setFile("uploaded_file", fileName));
		postDataBuilder.append("\r\n");
		
		int bytesRead,byteAvailable,bufferSize;
		byte[] buffer = null;
		int maxBufferSize = 5*1024*1024;
		File sourceFile= new File(sourceFileUri);
		try{
			FileInputStream fileInputStream = new FileInputStream(sourceFile);
			URL url = new URL("http://rastro.kr/app/test.php");
			
			conn = (HttpURLConnection)url.openConnection();
			conn.setDoInput(true);//InputStream으로 서버로 부터 응답을 받겠다는 옵션
			conn.setDoOutput(true);//OutputStream으로 Post데이터를 넘겨주겠다는 옵션
			conn.setUseCaches(false);//캐시를 사용하지 않겠다는 옵션
			conn.setRequestMethod("POST");//POST타입으로 설정
	        conn.setRequestProperty("Connection", "Keep-Alive");//커넥션을 재사용할수 있도록 하겠다
	        conn.setRequestProperty("ENCTYPE", "multipart/form-data");
	        conn.setRequestProperty("Content-Type", "multipart/form-data;boundary=" + boundary);      
			dos = new DataOutputStream(new BufferedOutputStream(conn.getOutputStream()));
			dos.writeUTF(postDataBuilder.toString());
			
			
			
			byteAvailable = fileInputStream.available();//현재 읽을 수 있는 바이트 수를 얻는다.
			bufferSize = Math.min(byteAvailable, maxBufferSize);//두수중 작은쪽 반환
			 buffer = new byte[bufferSize];
	         
             // read file and write it into form...
             bytesRead = fileInputStream.read(buffer, 0, bufferSize); 
               
             while (bytesRead > 0) {
                 
               dos.write(buffer, 0, bufferSize);
               byteAvailable = fileInputStream.available();
               bufferSize = Math.min(byteAvailable, maxBufferSize);
               bytesRead = fileInputStream.read(buffer, 0, bufferSize);  
               
              }
   
             // send multipart form data necesssary after file data...
             dos.writeBytes(lineEnd);
             dos.writeBytes(twoHyphens + boundary  + lineEnd);
   
             // Responses from the server (code and message)
             serverResponseCode = conn.getResponseCode();
             String serverResponseMessage = conn.getResponseMessage();
             InputStream is = conn.getInputStream();
             BufferedReader br = new BufferedReader(new InputStreamReader(is,"utf-8"));
             String line = null;
             StringBuilder sb=new StringBuilder();
 			while((line = br.readLine())!=null){
 				sb.append(line);
 			}
 			
 			is.close();
 			String result=sb.toString();
 			System.out.println(result);
 			
             fileInputStream.close();
             dos.flush();
             dos.close();
              
			 
		}catch(Exception e){
			
		}
	 return serverResponseCode;
		
	}
	 public static String setValue(String key, String value) {
	        return "Content-Disposition: form-data; name=\"" + key + "\"r\n\r\n"
	                + value;
	    }
	 public static String setFile(String key, String fileName) {
	        return "Content-Disposition: form-data; name=\"" + key
	                + "\";filename=\"" + fileName + "\"\r\n";
	    }
}
